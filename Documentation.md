**MDAnalysis** is a [python](http://www.python.org) framework to analyze molecular dynamics trajectories generated by [CHARMM](http://www.charmm.org), [NAMD](http://www.ks.uiuc.edu/Research/namd/), [LAMMPS](http://lammps.sandia.gov/), or [Gromacs](http://www.gromacs.org). It is mainly useful for geometric analyses, as there is no implemented potential model.

It is inspired by the Schulten Group's [MDtools](http://www.ks.uiuc.edu/Development/MDTools/) for python, and the source for the DCD reading code is derived from [VMD](http://www.ks.uiuc.edu/Research/vmd/). MDAnalysis is[GPL](http://www.gnu.org/licenses/gpl.html) licensed, except for the dcd reading code ([UIUC Open Source Licence](http://www.otm.illinois.edu/faculty/forms/opensource.asp)) which comes from VMD (and is GPL-compatible). Gromacs trajectories are utilizing the [Gromacs libxdrfile](http://www.gromacs.org/Developer_Zone/Programming_Guide/XTC_Library) library (GPL). MDAnalysis exposes trajectory data transparently as [NumPy](http://numpy.scipy.org/) arrays and as such it is easily extensible.

The standard **[Online Documentation](https://pythonhosted.org/MDAnalysis/)** is part of the distribution and can also be found in the source code repository. _It is more up-to-date and more comprehensive than this page_ (which mainly serves to showcase a few features and provide the general flavor of MDAnalysis).

See the [Installation instructions](Install) on how to download and build the library.

If you find MDAnalysis useful and employ it in published work we ask
you to acknowledge its use by citing the article

> N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein. MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations. _J. Comput. Chem._ **32** (2011),  2319â€“2327, doi:[10.1002/jcc.21787](http://dx.doi.org/10.1002/jcc.21787)


Thanks!

This page contains the following topics:


# Using MDAnalysis in python #

If you've installed MDAnalysis in the standard python modules location, from within the interpreter:

```
> from MDAnalysis import *
```
(The greater sign is the python prompt and should not be typed. It indicates input.)

The idea behind MDAnalysis is to get trajectory data into numpy arrays, where it can then be easily manipulated using all the power in numpy and scipy.
To start

IPython is really helpful here as you can interactively explore the objects and do analysis. The following tutorial will be run from an interactive ipython session.

```
> from MDAnalysis import *
> universe = Universe(psffilename, dcdfilename)
```

psffilename and dcdfilename should specify the full path to the files (although you can also use relative paths - just be aware when running the script from a different directory). You can also just load a psf file, although then you won't have access to any coordinates and a lot of the functions won't work.

```
> print universe.atoms
<AtomGroup with 27255 atoms>
```

## `AtomGroups` ##

The primary object you will work with is an AtomGroup, which has a number of convenient functions to obtain data from the group, such as:

  * coordinates() - returns an Nx3 array of atom coordinates
  * centerOfMass()
  * centerOfGeometry()
  * masses() - returns an array of all the masses
  * charges() - returns an array of all the charges
  * totalMass()
  * totalCharge()
  * momentOfInertia()
  * principleAxes()
  * radiusOfGyration()
  * indices() - returns an array of atom indices (related to the whole system)

AtomGroups can also be concatenated using the addition operator.

## Selections ##

Once you have the universe object, you can select atoms (using CHARMM's atom selection syntax):

```
> kalp = universe.selectAtoms("segid KALP")
```

selectAtoms() returns AtomGroups, so you can use the above functions on them. Selections always return an AtomGroup with atoms sorted according to their index in the psf (this is to ensure that there aren't any duplicates, which can happen with complicated selections).

You can group subselections using parentheses:
```
> universe.selectAtoms("segid DMPC and not (name H* or name O*)")
<AtomGroup with 3420 atoms>
```

Almost all the basic CHARMM selections work.

### Selection Keywords ###
Here's a list of all keywords. Note:
  * Keywords are _case sensitive_.
  * Atoms are automatically _ordered_ (see [notes on Collections](#Collections) for how to circumvent this if necessary).

See **[Selection Commands](http://mdanalysis.googlecode.com/git/package/doc/html/documentation_pages/selections.html)** in the [Online Docs](http://mdanalysis.googlecode.com/git/package/doc/html/index.html) for an up-to-date list of selections. The commands below are mainly here to provide the flavor. The online docs are authoritative.

#### Simple selections ####
<dl>
<blockquote><dt>protein, backbone</dt>
<dd>selects all atoms that belong to a standard set of residues, may not work for esoteric residues</dd>
<dt>segid</dt>
<dd>select by segid (as given in the topology), e.g. "segid 4AKE" or "segid DMPC"</dd>
<dt>resid</dt>
<dd>resid can take a range of numbers separated by a colon (inclusive) such as "resid 1:5". resids are taken directly from the topology.</dd>
<dt>resnum</dt>
<dd>resnum is the canonical residue number as, for instance, used in the original PDB structure. It can take a range of numbers separated by a colon (inclusive) such as "resnum 1:5". resnums are set to the resid by default but can be set to any other value by the user.</dd>
<dt>resname</dt>
<dd>select by residue name, e.g. "resname LYS"</dd>
<dt>name</dt>
<dd>select by atom name (as given in the topology). Often, this is force field dependent. Example: "name CA" (for C&alpha;& atoms) or "name OW" (for SPC water oxygen)</dd>
<dt>type</dt>
<dd>select by atom type; this is either a string or a number and depends on the force field; it is read from the topology file (e.g. the CHARMM PSF file contains numeric atom types). It has non-sensical values when a PDB or GRO file is used as a topology.</dd>
<dt>atom</dt>
<dd>a selector for a single atom consisting of <i>segid resid atomname</i>, e.g. "DMPC 1 C2" selects the C2 carbon of the first residue of the DMPC segment</dd>
<dt>altloc</dt>
<dd>a selector for a 'alternative location' atoms found in some PDB files, e.g. "resid 84 and altloc B" selects atoms of resid 84 with an altloc set to 'B'.</dd></blockquote>

</dl>

#### Boolean ####
<dl>
<blockquote><dt>not</dt>
<dd>all atoms not in the selection, e.g. "not protein" selects all atoms that aren't part of a protein</dd>
<dt>and, or</dt>
<dd>combine two selections according to the rules of boolean algebra, e.g. "protein and not ( resname ALA or resname LYS )" selects all atoms that belong to a protein, but are not in a lysine or alanine residue</dd>
</dl></blockquote>

#### Geometric ####

<dl>
<blockquote><dt>around</dt>
<dd>selects all atoms a certain cutoff away from another selection, e.g. "around 3.5 protein" selects all atoms not belonging to protein that are within 3.5 Angstroms from the protein</dd>
<dt>point</dt>
<dd>selects all atoms within a cutoff of a point in space, make sure coordinate is separated by spaces, e.g. "point 5.0 5.0 5.0  3.5" selects all atoms within 3.5 Angstroms of the coordinate (5.0, 5.0, 5.0)</dd>
<dt>prop</dt>
<dd>selects atoms based on position, using x, y, or z coordinate. Supports the abs keyword (for absolute value) and the following operators: <, >, <=, >=, ==, !=, e.g. "prop z >= 5.0" selects all atoms with z coordinate greater than 5.0; "prop abs z <= 5.0" selects all atoms within -5.0 <= z <= 5.0.</dd>
</dl></blockquote>

From version 0.6 onwards, geometric selections can use a k-d tree based, fast search algorithm (about three times faster than the previous version). However, it does not take periodicity into account. The fast algorithm is the default for _around_. See the python doc strings for details and how to change the default algorithm.

#### Connectivity ####
<dl>
<blockquote><dt>byres</dt>
<dd>selects all atoms that are in the same segment and residue as selection, e.g. specify the subselection after the byres keyword</dd>
</dl></blockquote>

#### Index ####
<dl>
<blockquote><dt>bynum</dt>
<dd>selects all atoms within a range of (1-based) inclusive indices, e.g. "bynum 1" selects the first atom in the universe; "bynum 5:10" selects atoms 5 through 10 inclusive</dd>
</dl></blockquote>


## Segments and Residues ##

When you first read in the psf file, MDAnalysis goes through and creates some helper objects for each segment and each residue. For example, I have a system with 5 segments - a protein (KALP), lipids (DMPC), water (BULK), sodium ions (SOD) and chloride ions (CL). The universe object has the following subobjects:

```
universe.KALP
universe.DMPC
universe.BULK
universe.SOD
universe.CL
```

Segments and Residues are all derived from AtomGroup, so you can use the functions listed above:

```
> print universe.DMPC.centerOfMass()
[-0.0053126   0.06834258 -0.0073338 ]
```

The DMPC object has a list of all residues (notice the Charmm nonmenclature), and can be accessed using array notation:

```
> universe.DMPC[0]
<Residue 'DMPC', 1>
```

Here's a list of all the KALP residues:

```
> list(universe.KALP)
[<Residue 'CHO', 1>,
 <Residue 'ALA', 2>,
 <Residue 'LYS', 3>,
 <Residue 'LYS', 4>,
 <Residue 'LEU', 5>,
 <Residue 'ALA', 6>,
 <Residue 'LEU', 7>,
 <Residue 'ALA', 8>,
 <Residue 'LEU', 9>,
 <Residue 'ALA', 10>,
 <Residue 'LEU', 11>,
 <Residue 'ALA', 12>,
 <Residue 'LEU', 13>,
 <Residue 'ALA', 14>,
 <Residue 'LYS', 15>,
 <Residue 'LYS', 16>,
 <Residue 'ALA', 17>,
 <Residue 'EAM', 18>]
```

You can also use slicing:

```
> universe.KALP[:5]
[<Residue 'CHO', 1>,
 <Residue 'ALA', 2>,
 <Residue 'LYS', 3>,
 <Residue 'LYS', 4>,
 <Residue 'LEU', 5>]
```

Each residue object returns individual atoms:

```
> universe.KALP[0][0]
< Atom 1: name 'HA' of type '3' of resid 'CHO', 1 and 'KALP'>
```

You can also use the dot notation along with the atom name to select a subset of atoms in an AtomGroup:

_Note_: this mostly works, but can be buggy if the atom name conflicts with some other internal variable or starts with a number.

```
> calphas = universe.KALP.CA

> print calphas
<AtomGroup with 17 atoms>

> list(calphas)
[< Atom 6: name 'CA' of type '22' of resname 'ALA', resid 2 and segid 'KALP'>,
 < Atom 16: name 'CA' of type '22' of resname 'LYS', resid 3 and segid 'KALP'>,
 < Atom 38: name 'CA' of type '22' of resname 'LYS', resid 4 and segid 'KALP'>,
 < Atom 60: name 'CA' of type '22' of resname 'LEU', resid 5 and segid 'KALP'>,
 < Atom 79: name 'CA' of type '22' of resname 'ALA', resid 6 and segid 'KALP'>,
 < Atom 89: name 'CA' of type '22' of resname 'LEU', resid 7 and segid 'KALP'>,
 < Atom 108: name 'CA' of type '22' of resname 'ALA', resid 8 and segid 'KALP'>,
 < Atom 118: name 'CA' of type '22' of resname 'LEU', resid 9 and segid 'KALP'>,
 < Atom 137: name 'CA' of type '22' of resname 'ALA', resid 10 and segid 'KALP'>,
 < Atom 147: name 'CA' of type '22' of resname 'LEU', resid 11 and segid 'KALP'>,
 < Atom 166: name 'CA' of type '22' of resname 'ALA', resid 12 and segid 'KALP'>,
 < Atom 176: name 'CA' of type '22' of resname 'LEU', resid 13 and segid 'KALP'>,
 < Atom 195: name 'CA' of type '22' of resname 'ALA', resid 14 and segid 'KALP'>,
 < Atom 205: name 'CA' of type '22' of resname 'LYS', resid 15 and segid 'KALP'>,
 < Atom 227: name 'CA' of type '22' of resname 'LYS', resid 16 and segid 'KALP'>,
 < Atom 249: name 'CA' of type '22' of resname 'ALA', resid 17 and segid 'KALP'>,
 < Atom 259: name 'CA' of type '23' of resname 'EAM', resid 18 and segid 'KALP'>]

> print calphas.coordinates()
[[ -0.40643615   0.20670871 -14.56624699]
 [  2.74141145   1.50868964 -12.98140526]
 [  1.70380127   4.80918837 -11.31853104]
 ...
 [ -2.13122082  -2.77723908  11.90110874]
 [ -1.10523653  -3.76820683  15.34832859]]
```

If you have a segment, you can also name residues:

```
> print universe.KALP.LYS
<ResidueGroup [<Residue 'LYS', 3>, <Residue 'LYS', 4>, <Residue 'LYS', 18>, <Residue 'LYS', 19>]>
```

which will return a ResidueGroup. To get all the c-alphas of the lysine residues:

```
> print universe.KALP.LYS.CA
<AtomGroup with 4 atoms>
```

You should be able to access any subset of atoms using the Segment and Residue classes, which can often times be faster than using selectAtoms

## Analyzing Trajectories ##

The trajectory information is stored in the _trajectory_ object which is part of universe:

```
> print universe.trajectory
< DCDReader 'kalp16.dcd' with 7500 frames of 27369 atoms (0 fixed) >
```

The current timestep information - frame (timestep number), periodic box dimensions, and coordinates - is stored in a _Timestep_ object:

```
> print universe.trajectory.ts
< Timestep 1 with unit cell dimensions array([ 54.30002011,  54.79000900,  87.83924582,  90.        ,  90.        , 90.],'f') >
```


The trajectory reader follows Charmm's convention and the first frame of the trajectory has the index **1** and _not_ 0, i.e. _trajectories are 1-based_.

One thing to note is that the _trajectory_ object only has one timestep of data read in at a time. To change to a new timestep just change the index passed into the _trajectory_ object:
```
> universe.trajectory[6]
> print universe.trajectory.ts
< Timestep 6 with unit cell dimensions array([ 54.70000076,  54.70000076,  88.48955536,  90.        ,  90.        , 90.],'f') >
```

The timestep object returned when you index the _trajectory_ reader is a pointer to the internal one, so any changes made to the coordinates will be reflected when accessing the internal _ts_ object. The changes are not written back to the file, so you can always reread that timestep to reset it.

The _trajectory_ object can be treated as a list (actually, a python iterator), so you can iterate through the trajectory:

```
> for ts in universe.trajectory:
      print ts.frame
1
2
3
...
```

_AtomGroup_ objects have a link to the trajectory's _Timestep_ (ts) object, so they always return properties based on the currently loaded timestep. For example:

```
> for ts in universe.trajectory:
      print ts.frame, universe.Kalp.centerOfMass()
1 [ 0.19409591  1.28646819 -0.60652838]
2 [ 0.12801227  0.70701863 -0.60693483]
3 [ 0.15608463  0.76454026 -0.57373664]
4 [ 0.04614724  0.75750257 -0.25540986]
5 [ 0.22033799  0.30273071 -0.22080257]
...
```


**Note**: The _trajectory_ object is an "alias" for a so-called trajectory reader that corresponds to the trajectory format. For instance, DCD files are really read by a _DCDReader_ and XTCs by a _XTCReader_. These formats have different technical limitations and hence the readers can have different capabilities as described below.

All _TrajectoryReader_ support the following minimum functionality (also known as the [Trajectory API](http://mdanalysis.googlecode.com/git-history/develop/package/doc/html/documentation_pages/coordinates/init.html#trajectory-api)):
  * iteration, i.e. `for ts in universe.trajectory`
  * _next()_ method to advance to next time step
  * _rewind()_ method to reposition to the beginning of the trajectory (frame 1)
  * _close\_trajectory()_ to close the file


### Trajectory Readers ###
MDAnalysis guesses the file type from the file extension (unless the keyword _format_ is provided to `Universe()`). Independent of the file format, the trajectory is always accessible as
```
> universe.trajectory
```

#### DCD file format ####

The DCDReader is the original full-feature implementation (based on catdcd). It supports all functionality (except "frozen atoms", or at least this is untested).

The DCDReader can be indexed using standard array notation in order to fast-forward to any frame (although this might be problematic for trajectories greater 2 GiO in size):

```
> print universe.trajectory[5]
< Timestep 6 with unit cell dimensions array([ 54.70000076,  54.70000076,  88.48955536,  90.        ,  90.        , 90.],'f') >
```

You can also iterate through subsets of the trajectory using slice notation (`trajectory[start:stop:step]`).

#### XTC and TRR formats ####

The _XTCReader_ supports reading of Gromacs [XTC](http://manual.gromacs.org/current/online/xtc.html) limited-precision compressed trajectories whereas _TRRReader_ accesses [TRR](http://manual.gromacs.org/current/online/trr.html) full precision trajectories.

The underlying library ([libxdrfile](http://www.gromacs.org/Developer_Zone/Programming_Guide/XTC_Library)) does not support random access of XTC files, hence access via indexing and slicing is much slower than for the DCDReader (and reversing the trajectory with negative step sizes is not supported).

_[Timeseries](#Timeseries)_ and _[Collections](#Collections)_  are not supported at the moment.

Coordinates and velocities are read from TRR files; forces are not supported at the moment.

#### PDBReader ####

Coordinates can be read from a single [PDB file](http://deposit.rcsb.org/adit/docs/pdb_atom_format.html) and trajectories can read from multi-PDB files. It uses Bio.PDB and hence can deal with pretty much any kind of pdb file but it can be a bit slow for large files.

Iteration and next() work.

As a special feature, reading a PDB with B-factor information populates the Bfactor property of an _Atom_.

By default the _PrimitivePDBReader_ is used over the _PDBReader_ (which is based on Bio.PDB). The Bio.PDB reader can be selected with the Universe keyword _permissive_ = `False` and it is better at handling complicated PDB files, as it implements the full PDB standard.

#### GROReader ####

Coordinates can be read from a single [GRO file](http://manual.gromacs.org/current/online/gro.html) (multi-GRO trajectories are not supported). The _GROReader_ is about 4x faster than the Bio.PDB implementation of the _PDBReader_ (mainly because the _PDBReader_ can deal with fairly esoteric things such as AltLocs whereas the _GROReader_ assumes to have a rather simple input file).

Iteration and next() work but are limited to a single frame.

Reading of velocities is not supported (as they are not used in MDAnalysis at the moment).

### Timeseries ###

**Only available for _DCDReader_**

_Timeseries_ lets you calculate geometric properties over the entire trajectory.

Sometimes iterating through the entire trajectory using python is too slow. MDAnalysis includes tools to extract entire timeseries from the trajectory into numpy arrays so they can be processed in one go (inspired by Charmm's correl capabilities).

There are two ways of doing this, depending on what properties you wish to extract. The first is simpler, but only extracts timeseries of coordinate data, while the second one is more versatile but requires more initial setup.

#### Coordinate timeseries ####

This is the easiest way to pull out individual atomic timeseries. All it requires is an AtomGroup.

```
> kalp_coord = universe.trajectory.timeseries(universe.KALP)
```

Depending on the size of the trajectory, this call can take from a few seconds to several minutes. One thing to note is that the array for all the coordinates is preallocated, so make sure you have enough memory!!

You can also pass in several options to the timeseries function:

```
> kalp_coord = universe.trajectory.timeseries(universe.KALP, start=0, stop=5, skip=1, format="afc")
> print kalp_coord.shape
(314, 6, 3)
```

Most options are self explanatory (note that start and stop are inclusive, and both start and stop can use negative indexing, but start must always be less than or equal to stop), but format needs some explanation. The default timeseries format is (a)tom, (f)rame, (c)oordinate, so above you can see there are 314 atoms, 6 frames, and 3 coordinates per frame per atom.kalp\_coord[0](0)[0](0) will return the coordinate of the first atom in the KALP group in the first timestep. Depending on the analysis you will be performing, you might wish the data arranged in another format. All 6 possible combinations of atom, frame and coordinate are allowed (just rearrange the 3 letters).
Correl timeseries

#### Collections ####

Sometimes you need more involved timeseries. For example, a timeseries of the center of mass of a group, or only the z position of a subset of atoms (for computing a potential profile, for example). This can be done with `DCDReader`'s correl function, which utilizes the `Timeseries` module (however, see next section for a new way to retrieve timeseries). First you must build the collection using the `TimeseriesCollection` class (a default one is created and populated in the main namespace, but you can create as many collections as you wish):

```
> from MDAnalysis import collection
> print collection
<TimeseriesCollection with 0 timeseries objects>

> collection.addTimeseries(Timeseries.CenterOfMass(universe.KALP))
> print collection
<TimeseriesCollection with 1 timeseries object>

> print collection[0]
<CenterOfMass timeseries object is not populated with data>

> data = universe.trajectory.correl(collection, stop=5)
> print data.shape
(3, 6)
```

The correl function also takes start, stop and skip as additional arguments. The format argument is not implemented yet - currently the format defaults to (property, frame). So the example above, there is an array for each axes of the center of mass coordinate (data[0](0) is the timeseries for the x coordinate of the center of mass, data[1](1) is the y coordinate, and so on).

Currently implemented timeseries are Atom, Distance, Angle, Dihedral, CenterOfGeometry, and CenterOfMass. Others can be added but this requires writing some C code. Several of the Timeseries objects require a code argument to specify the data they return:

<dl>
<blockquote><dt>Atom(code, selection)</dt>
<dd>code can be x, y, z or v (the entire coordinate vector)</dd>
<dt>Distance(code, selection)</dt>
<dd>code can be d (actual distance vector) or r (length of vector), doesn't currently take periodic boundary conditions into account</dd>
</dl></blockquote>

Note that each timeseries only pertains to one property (ie to get the dihedral angles of all the residues in a protein you must create a separate Dihedral object for each one). Also, Distance takes 2 atoms, Angle takes 3, and Dihedral takes 4. Atom can take either one atom, or for convenience, an AtomGroup. Because of the way universe.selectAtoms() sorts the atoms in the AtomGroup before returning them (this is to eliminate possible duplicates in the selection), you must create multiple selections and concatenate them (which doesn't sort them) before passing into the Timeseries object. universe.selectAtoms() does this automatically if you pass multiple strings.

For example this won't work as you might expect:

```
# WRONG!
> print list(universe.selectAtoms("segid DMPC and ( resid 3 or resid 2 ) and name P"))
[< Atom 452: name 'P' of type '180' of resid 'DMPC', 2 and 'DMPC'>,
 < Atom 570: name 'P' of type '180' of resid 'DMPC', 3 and 'DMPC'>]
```

Notice how the residues are returned with psf ordering. However, if you do this:

```
> print list(universe.selectAtoms("segid DMPC and resid 3 and name P", "segid DMPC and resid 2 and name P"))
[< Atom 570: name 'P' of type '180' of resid 'DMPC', 3 and 'DMPC'>,
 < Atom 452: name 'P' of type '180' of resid 'DMPC', 2 and 'DMPC'>]
```

The atoms will be ordered the way you specified.

You can combine as many timeseries as you want - just make sure to index the resulting timeseries correctly to extract out the relevant data (although see the next section for an easier way to access the resulting timeseries). For example:

```
> collection.clear()
> collection.addTimeseries(Timeseries.CenterOfMass(universe.KALP))
> collection.addTimeseries(Timeseries.Atom("z", universe.DMPC.P))
> data = universe.trajectory.correl(collection, stop=5)
> print data.shape
(93, 6)
```

The first three timeseries correspond to the center of mass of KALP, and the last ninety are the z position timeseries of each phosphate atom in the DMPC segment. If instead of asking for the z position of the phosphate atoms, you did this:

```
> collection.clear()
> collection.addTimeseries(Timeseries.CenterOfMass(universe.KALP))
> collection.addTimeseries(Timeseries.Atom("v", universe.DMPC.P))
> data = universe.trajectory.correl(collection, stop=5)
> print data.shape
(273, 6)
```

Now the first three are again the center of mass of KALP, the next three are the 3D coordinate of the first phosphate, the next three are for the second phosphate, and so on (there are 90 lipids).

Once you have them in numpy arrays you can use indexing to pull out the data you want:

```
> print data[3::3].shape
(90, 6)
```

will, for example return the x coordinate timeseries of all the phosphates.

### `TimeseriesCollection` ###

`TimeseriesCollection` is a new and improved way to collect and access `Timeseries` in MDAnalysis.

The `TimeseriesCollection` object now has a new function, `compute()`, which takes a `DCDReader` as an argument and generates the timeseries:

```
> collection.clear()
> collection.addTimeseries(Timeseries.CenterOfMass(universe.KALP))
> collection.addTimeseries(Timeseries.Atom("v", universe.DMPC.P))
> collection.compute(universe.trajectory, stop=5)
```

`compute()` also takes _start_, _stop_ and _skip_ as arguments. This function will no longer return the timeseries data, instead populating each of the `Timeseries` objects with their respective timeseries. You can access the collection as a list:

```
> print collection[0]
<CenterOfMass timeseries object is populated with data>
```

The timeseries data is stored in the `__data__` field, and the `Timeseries` subclasses (`Atom`, `Distance`, `Dihedral`, etc) can be roughly treated as arrays (you can pass them into numpy functions directly, but complicated indexing doesn't work):

```
> kalp_com = collection[0]
> print kalp_com.shape
(3, 6)

> print numpy.average(kalp_com, axis=1)
array([ 0.1456862 ,  0.83971408, -0.49546348])
```

gives you the average center of mass of KALP for the first 6 frames.

## Helper functions ##

Numpy/Numeric is very powerful. For example, say you want a distance matrix between two sets of atoms:

```
> kalp = universe.KALP.coordinates()
> phosphates = universe.DMPC.P.coordinates()
> dist = numpy.sqrt(numpy.add.reduce(numpy.square(kalp[numpy.newaxis,:] - phosphates[:,numpy.newaxis]), axis=-1))
```

dist will contain an NxM array of distances between each atom in KALP and each phosphate in the lipid bilayer. But this won't take into account periodic boundaries. A distance module in MDAnalysis will do this for you:

```
> box = universe.trajectory.ts.dimensions[:3]
> from MDAnalysis.analysis.distances import distance_array
> distance_array(kalp, phosphates, box)
```

[distance\_array()](http://mdanalysis.googlecode.com/git/package/doc/html/documentation_pages/analysis/distances.html#MDAnalysis.analysis.distances.distance_array) may also be faster and more memory efficient for large coordinate arrays since it avoids the intermediate arrays that the above numpy expression generates.

# Examples #

See [Examples](Examples).